classdef caseDistributionSystemMeasure < caseDistributionSystem
    % This is the class of distribution system. We assume all the
    % evaluations are conducted under practical measurements
    
    properties
        dataE               % the estimated data
        dataO               % the process data in the optimization iterations
        boundA              % the approximated bound
        sigmaReal           % the deviation of the real state variables
        prior               % the prior assumptions of the G and B matrix
        
        A_FIM               % the approximated fisher information matrix
        A_FIMP              % the (sparse) FIM of active power injection
        A_FIMQ              % the (sparse) FIM of reactive power injection
        
        initPar             % the initial estimation of parameters and state variables
        truePar             % the ground truth of the parameters
        
        grad                % the gradient vector
        gradP               % the gradient vector from the measurement of P
        gradQ               % the gradient vector from the measurement of Q
        gradVm              % the gradient vector from the measurement of Vm
        gradVa              % the gradient vector from the measurement of Va
        numGrad             % the number of the gradient elements

    end
    
    methods
        function obj = caseDistributionSystemMeasure(caseName, numSnap, range)
            % the construction function
            obj = obj@caseDistributionSystem(caseName, numSnap, range);
        end
        
        function obj = preEvaluation(obj, varargin)
            % This method evaluate the parameters before approximating the
            % FIM. The evaluated value has low accuracy. We only use one
            % snapshot for the Vm and Va.
            
            if nargin == 2
                obj.prior = varargin{1};
            elseif nargin == 1
                obj.prior.Gmin = 0.1;
                obj.prior.Bmin = 0.1;
                obj.prior.ratio = 0.05;
            end
            
            % we first evaluate the vm and the va
%             obj.dataE.Vm = obj.data.Vm;%_noised;
%             obj.dataE.Va = obj.data.Va;%_noised;

            obj.sigmaReal.Vm = cov(obj.data.Vm');
            mu = mean(obj.data.Vm, 2);
            rng(5);
            obj.dataE.Vm = mvnrnd(mu, obj.sigmaReal.Vm, obj.numSnap)';
            
            obj.sigmaReal.Va = cov(obj.data.Va');
            mu = mean(obj.data.Va, 2);
            rng(6);
            obj.dataE.Va = mvnrnd(mu, obj.sigmaReal.Va, obj.numSnap)';
            
%             obj.dataE.Vm = obj.data.Vm;%_noised;
            
            % We then evaluate the G and B. 
%             obj.dataE.G = obj.data.G;
%             obj.dataE.B = obj.data.B;
            
            obj = approximateY(obj);
            
            obj.dataE.Va = zeros(obj.numBus, obj.numSnap);
            obj.dataE.Va(2:end, :) = - (obj.dataE.G(2:end, 2:end)) \ obj.data.P_noised(2:end, :);
%             mu = mean(obj.data.Va, 2);
%             obj.sigmaReal.P = cov(obj.data.P');
%             obj.sigmaReal.Va = zeros(obj.numBus, obj.numBus);
%             obj.sigmaReal.Va(2:end, 2:end) = ...
%                 ((1.5*obj.dataE.G(2:end, 2:end)) \ obj.sigmaReal.P(2:end, 2:end)) / (1.5*obj.dataE.G(2:end, 2:end));
%             rng(7);
%             obj.dataE.Va = mvnrnd(mu, obj.sigmaReal.Va, obj.numSnap)';
%             obj.dataE.Va(2:end, :) = -obj.dataE.G(2:end, 2:end) \ obj.data.P_noised(2:end, :);
        end
        
        function obj = approximateFIM(obj, varargin)
            % This method approximate the fisher information matrix based
            % on the pre-evaluation results of the parameters.
            if nargin == 2
                obj.k = varargin{1};
            elseif nargin == 1
                obj.k.G = 5;
                obj.k.B = 10;
                obj.k.vm = 10;
                obj.k.va = 1000;
            end
            % initialize the A_FIM matrix
            obj.numFIM.G = (1 + obj.numBus) * obj.numBus / 2;
            obj.numFIM.B = (1 + obj.numBus) * obj.numBus / 2;
            obj.numFIM.Vm = obj.numSnap * (obj.numBus - 1); % exclude the source bus
            obj.numFIM.Va = obj.numSnap * (obj.numBus - 1);
            obj.numFIM.Sum = obj.numFIM.G + obj.numFIM.B + obj.numFIM.Vm + obj.numFIM.Va;
            
            obj.A_FIM = zeros(obj.numFIM.Sum, obj.numFIM.Sum);
            obj.A_FIMP = sparse(obj.numFIM.Sum, obj.numFIM.Sum);
            obj.A_FIMQ = sparse(obj.numFIM.Sum, obj.numFIM.Sum);
            obj.FIMVm = sparse(obj.numFIM.Sum, obj.numFIM.Sum);
            obj.FIMVa = sparse(obj.numFIM.Sum, obj.numFIM.Sum);
            
            % calculate the sub-matrix of P of all snapshots and all buses
            for i = 1:obj.numBus
                if obj.isMeasure.P(i)
                    for j = 1:obj.numSnap
                        obj = approximateFIMP(obj, i, j);
                    end
                end
            end
            obj.A_FIM = obj.A_FIM + full(obj.A_FIMP);
            % calculate the sub-matrix of Q of all snapshots and all buses
            for i = 1:obj.numBus
                if obj.isMeasure.Q(i)
                    for j = 1:obj.numSnap
                        obj = approximateFIMQ(obj, i, j);
                    end
                end
            end
            obj.A_FIM = obj.A_FIM + full(obj.A_FIMQ);
            % calculate the sub-matrix of Vm of all snapshots and all buses
            for i = 1:obj.numBus
                if obj.isMeasure.Vm(i)
                    for j = 1:obj.numSnap
                        obj = buildFIMVm(obj, i, j);
                    end
                end
            end
            obj.A_FIM = obj.A_FIM + full(obj.FIMVm);
            % calculate the sub-matrix of Va of all snapshots and all buses
            for i = 1:obj.numBus
                if obj.isMeasure.Va(i)
                    for j = 1:obj.numSnap
                        obj = buildFIMVa(obj, i, j);
                    end
                end
            end
            obj.A_FIM = obj.A_FIM + full(obj.FIMVa);
        end
        
        function obj = approximateFIMP(obj, bus, snap)
            % This method approximate the P part of FIM. We ignore the sin
            % part of the power flow equations.
            h = sparse(obj.numFIM.Sum, 1);
            theta_ij = obj.dataE.Va(bus, snap) - obj.dataE.Va(:, snap);
%             Theta_ij = repmat(obj.dataE.Va(:, snap), 1, obj.numBus) - repmat(obj.dataE.Va(:, snap)', obj.numBus, 1);
%             % G_ij\cos(\Theta_ij)+B_ij\sin(\Theta_ij)
%             GBThetaP = obj.dataE.G .* cos(Theta_ij) + obj.dataE.B .* sin(Theta_ij);
%             % G_ij\sin(\Theta_ij)-B_ij\cos(\Theta_ij)
%             GBThetaQ = obj.dataE.G .* sin(Theta_ij) - obj.dataE.B .* cos(Theta_ij);
            
            % G matrix
            H_G = zeros(obj.numBus, obj.numBus);
            H_G(bus, :) = obj.dataE.Vm(bus, snap) * obj.dataE.Vm(:, snap)' / obj.k.G; % .* cos(theta_ij')
            h_G = obj.matToCol(H_G);
            h(1:obj.numFIM.G) = h_G;
            
            % B matrix
            H_B = zeros(obj.numBus, obj.numBus);
            H_B(bus, :) = obj.dataE.Vm(bus, snap) * obj.dataE.Vm(:, snap)' .* sin(theta_ij') / obj.k.B;
            h_B = obj.matToCol(H_B);
            h(obj.numFIM.G+1:obj.numFIM.G+obj.numFIM.B) = h_B;
            
            % Vm
            % the first order term of other Vm
            H_Vm = zeros(obj.numBus, obj.numSnap);
            h_Vm = obj.dataE.Vm(bus, snap) * obj.dataE.G(:, bus) / obj.k.vm; % obj.dataE.G(:, bus)
            % the second order term of Vm(bus)
            h_Vm(bus) = 2*obj.dataE.Vm(bus, snap) * obj.dataE.G(bus, bus) / obj.k.vm; % obj.dataE.G(bus, bus)
            % the first order term of Vm(bus)
            fOrderVm = obj.dataE.Vm(:, snap) .* obj.dataE.G(:, bus) / obj.k.vm; % obj.dataE.G(:, bus)
            fOrderVm(bus) = 0;
            h_Vm(bus) = h_Vm(bus) + sum(fOrderVm);
            H_Vm(:, snap) = h_Vm;
            % remove the source bus whose magnitude is not the state variable
            H_Vm(1, :) = []; 
            h_VmLarge = reshape(H_Vm', [], 1);
            h(obj.numFIM.G+obj.numFIM.B+1:obj.numFIM.G+obj.numFIM.B+obj.numFIM.Vm) = h_VmLarge;
            
            % Va
            H_Va = zeros(obj.numBus, obj.numSnap);
            h_Va = obj.dataE.Vm(bus, snap) * obj.dataE.Vm(:, snap) .* (- obj.dataE.B(:, bus)) / obj.k.va; % (- obj.dataE.B(:, bus))
            h_Va(bus) = h_Va(bus)-sum(obj.dataE.Vm(bus, snap) * obj.dataE.Vm(:, snap) .* (- obj.dataE.B(:, bus))) / obj.k.va; % (- obj.dataE.B(:, bus)))
            H_Va(:, snap) = h_Va;
            % remove the source bus whose magnitude is not the state variable
            H_Va(1, :) = []; 
            h_VaLarge = reshape(H_Va', [], 1);
            h(obj.numFIM.G+obj.numFIM.B+obj.numFIM.Vm+1:end) = h_VaLarge;
            
            % build FIMP
            h = h / obj.sigma.P(bus);
            FIMPThis = h * h';
            obj.A_FIMP = obj.A_FIMP + FIMPThis;
        end
        
        function obj = approximateFIMQ(obj, bus, snap)
            % This method approximate the Q part of FIM. We ignore the sin
            % part of the power flow equations.
            h = sparse(obj.numFIM.Sum, 1);
            theta_ij = obj.dataE.Va(bus, snap) - obj.dataE.Va(:, snap);
%             Theta_ij = repmat(obj.dataE.Va(:, snap), 1, obj.numBus) - repmat(obj.dataE.Va(:, snap)', obj.numBus, 1);
%             % G_ij\cos(\Theta_ij)+B_ij\sin(\Theta_ij)
%             GBThetaP = obj.dataE.G .* cos(Theta_ij) + obj.dataE.B .* sin(Theta_ij);
%             % G_ij\sin(\Theta_ij)-B_ij\cos(\Theta_ij)
%             GBThetaQ = obj.dataE.G .* sin(Theta_ij) - obj.dataE.B .* cos(Theta_ij);
            
            % G matrix
            H_G = zeros(obj.numBus, obj.numBus);
            H_G(bus, :) = obj.dataE.Vm(bus, snap) * obj.dataE.Vm(:, snap)' .* sin(theta_ij') / obj.k.G;
            h_G = obj.matToCol(H_G);
            h(1:obj.numFIM.G) = h_G;
            
            % B matrix
            H_B = zeros(obj.numBus, obj.numBus);
            H_B(bus, :) = - obj.dataE.Vm(bus, snap) * obj.dataE.Vm(:, snap)' / obj.k.B; %  .* cos(theta_ij')
            h_B = obj.matToCol(H_B);
            h(obj.numFIM.G+1:obj.numFIM.G+obj.numFIM.B) = h_B;
            
            % Vm
            % the first order term of other Vm
            H_Vm = zeros(obj.numBus, obj.numSnap);
            h_Vm = obj.dataE.Vm(bus, snap) * (-obj.dataE.B(:, bus)) / obj.k.vm; % (-obj.dataE.B(:, bus))
            % the second order term of Vm(bus)
            h_Vm(bus) = 2*obj.dataE.Vm(bus, snap) * (-obj.dataE.B(bus, bus)) / obj.k.vm; % (-obj.dataE.B(bus, bus))
            % the first order term of Vm(bus)
            fOrderVm = obj.dataE.Vm(:, snap) .* (-obj.dataE.B(:, bus)) / obj.k.vm; % (-obj.dataE.B(:, bus))
            fOrderVm(bus) = 0;
            h_Vm(bus) = h_Vm(bus) + sum(fOrderVm);
            H_Vm(:, snap) = h_Vm;
            % remove the source bus whose magnitude is not the state variable
            H_Vm(1, :) = []; 
            h_VmLarge = reshape(H_Vm', [], 1);
            h(obj.numFIM.G+obj.numFIM.B+1:obj.numFIM.G+obj.numFIM.B+obj.numFIM.Vm) = h_VmLarge;
            
            % Va
            H_Va = zeros(obj.numBus, obj.numSnap);
            h_Va = - obj.dataE.Vm(bus, snap) * obj.dataE.Vm(:, snap) .* obj.dataE.G(:, bus) / obj.k.va; % obj.dataE.G(:, bus)
            h_Va(bus) = h_Va(bus)+sum(obj.dataE.Vm(bus, snap) * obj.dataE.Vm(:, snap) .* obj.dataE.G(:, bus)) / obj.k.va; % obj.dataE.G(:, bus))
            H_Va(:, snap) = h_Va;
            % remove the source bus whose magnitude is not the state variable
            H_Va(1, :) = []; 
            h_VaLarge = reshape(H_Va', [], 1);
            h(obj.numFIM.G+obj.numFIM.B+obj.numFIM.Vm+1:end) = h_VaLarge;
            
            % build FIMQ
            h = h / obj.sigma.Q(bus);
            FIMQThis = h * h';
            obj.A_FIMQ = obj.A_FIMQ + FIMQThis;
        end
        
        function obj = calABound(obj, varargin)
            % this method calculate the bound from the A_FIM matrix;
            
            if nargin == 3
                obj.admittanceOnly = varargin{1};
                obj.topoPrior = varargin{2};
            elseif nargin == 2
                obj.admittanceOnly = varargin{1};
                obj.topoPrior = false(obj.numBus, obj.numBus);
            elseif nargin == 1
                obj.admittanceOnly = false;
                obj.topoPrior = false(obj.numBus, obj.numBus);
            end
            
            % build the indexes we really care about
            delCols = [obj.matToCol(obj.topoPrior)>1e-4;obj.matToCol(obj.topoPrior)>1e-4];
            obj.numFIM.index = true(obj.numFIM.Sum, 1);
            obj.numFIM.index(delCols) = false;
            obj.numFIM.del = sum(delCols)/2;
            
            % for [A B; B' C], we calculate A-B/C*B'
            if obj.admittanceOnly
                obj.numFIM.index = obj.numFIM.index(1:obj.numFIM.G+obj.numFIM.B);
                A = obj.A_FIM(1:obj.numFIM.G+obj.numFIM.B, 1:obj.numFIM.G+obj.numFIM.B);
                B = obj.A_FIM(1:obj.numFIM.G+obj.numFIM.B, obj.numFIM.G+obj.numFIM.B+1:end);
                C = obj.A_FIM(obj.numFIM.G+obj.numFIM.B+1:end, obj.numFIM.G+obj.numFIM.B+1:end);
                obj.A_FIM = A - B/C*B';
                cov = obj.A_FIM(obj.numFIM.index, obj.numFIM.index)\eye(sum(obj.numFIM.index));
                var = diag(cov);
            else
                cov = obj.A_FIM(obj.numFIM.index, obj.numFIM.index)\eye(sum(obj.numFIM.index));
                var = diag(cov);
%                 % we construct a Hermitian matrix H and use Cholesky
%                 % decomposition to compute the inverse matrix
%                 FIM = obj.A_FIM(obj.numFIM.index, obj.numFIM.index);
%                 H = FIM * FIM';
%                 U = chol(H);
%                 Uinv = U \ eye(size(U));
%                 Cov = H' * (Uinv * Uinv');
            end
            if min(var) < 0
                var = abs(var);
                cov = cov - diag(diag(cov)) + diag(var);
                fprintf('We use the absolute value of the variance.\n');
            end
            
            obj.boundA.total = sqrt(var);
            obj.boundA.cov = cov;
            
            boundG = zeros(obj.numFIM.G, 1);
            boundG(obj.numFIM.index(1:obj.numFIM.G)) = obj.boundA.total(1:obj.numFIM.G-obj.numFIM.del) / obj.k.G;
            obj.boundA.total(1:obj.numFIM.G-obj.numFIM.del) = obj.boundA.total(1:obj.numFIM.G-obj.numFIM.del) / obj.k.G;
            obj.boundA.G = obj.colToMat(boundG, obj.numBus);
            
            boundB = zeros(obj.numFIM.B, 1);
            boundB(obj.numFIM.index(1:obj.numFIM.G)) = ...
                obj.boundA.total(obj.numFIM.G+1-obj.numFIM.del:obj.numFIM.G+obj.numFIM.B-2*obj.numFIM.del) / obj.k.B;
            obj.boundA.total(obj.numFIM.G+1-obj.numFIM.del:obj.numFIM.G+obj.numFIM.B-2*obj.numFIM.del) = ...
                obj.boundA.total(obj.numFIM.G+1-obj.numFIM.del:obj.numFIM.G+obj.numFIM.B-2*obj.numFIM.del) / obj.k.B;
            obj.boundA.B = obj.colToMat(boundB, obj.numBus);
            
            obj.boundA.G_relative = abs(obj.boundA.G ./ repmat(diag(obj.data.G), 1, obj.numBus));
            obj.boundA.B_relative = abs(obj.boundA.B ./ repmat(diag(obj.data.B), 1, obj.numBus));
            obj.boundA.G_relative_col = reshape(obj.boundA.G_relative, [], 1);
            obj.boundA.B_relative_col = reshape(obj.boundA.B_relative, [], 1);
            
            if ~obj.admittanceOnly
                obj.boundA.Vm = ...
                    obj.boundA.total(obj.numFIM.G+obj.numFIM.B+1-2*obj.numFIM.del...
                    :obj.numFIM.G+obj.numFIM.B+obj.numFIM.Vm-2*obj.numFIM.del) / obj.k.vm;
                obj.boundA.total(obj.numFIM.G+obj.numFIM.B+1-2*obj.numFIM.del...
                    :obj.numFIM.G+obj.numFIM.B+obj.numFIM.Vm-2*obj.numFIM.del)...
                    = obj.boundA.Vm;
                obj.boundA.Va = ...
                    obj.boundA.total(obj.numFIM.G+obj.numFIM.B+obj.numFIM.Vm+1-2*obj.numFIM.del...
                    :obj.numFIM.Sum-2*obj.numFIM.del) / obj.k.va;
                obj.boundA.total(obj.numFIM.G+obj.numFIM.B+obj.numFIM.Vm+1-2*obj.numFIM.del...
                    :obj.numFIM.Sum-2*obj.numFIM.del)...
                    = obj.boundA.Va;
            end
        end
        
        function obj = approximateY(obj)
            % This method approximate the Y matrix by the measurements. We
            % use the simple Ohom's law to provide an initial value of Y.
            % We also assume the G/B ratio is a constant.
            rng(103);
            randG = 0.75 + 0.5 * randn(size(obj.data.G));
            rng(104);
            randB = 0.75 + 0.5 * randn(size(obj.data.B));
            obj.dataE.G = obj.data.G .* randG;
            obj.dataE.B = obj.data.B .* randB;
%             % The approximation of the diagonal elements
%             diagG = diag(obj.dataE.G);
%             diagB = diag(obj.dataE.B);
            
            % approximate the topology using Vm data only
            % ranking the Vm
            Vm = obj.data.Vm_noised;
            Topo = logical(eye(obj.numBus));
            VmMean = mean(Vm, 2);
            [~, VmOrder] = sort(VmMean,'descend');
            
            assert (VmOrder(1) == 1); % the first bus is the source bus
            
            Vm = movmean(Vm, floor(obj.numSnap/20)+1, 2);
            corr = corrcoef(Vm');
            corr(isnan(corr)) = 0; % one can also simulate some disturbance in the source bus voltage
            for i = 2:obj.numBus
                % iterate each bus
                [~, loc] = max(corr(VmOrder(i), VmOrder(1:i-1))); % the location of the connected bus
                Topo(VmOrder(i), VmOrder(loc)) = true;
                Topo(VmOrder(loc), VmOrder(i)) = true;
            end
            
%             Topo = obj.data.G~=0;

            % approximate the parameter
            IP = obj.data.IP_noised;
            IQ = obj.data.IQ_noised;
            G = IP * obj.data.Vm_noised' / (obj.data.Vm_noised * obj.data.Vm_noised');
            B = - IQ * obj.data.Vm_noised' / (obj.data.Vm_noised * obj.data.Vm_noised');
            G_ols = zeros(obj.numBus, obj.numBus);
            B_ols = zeros(obj.numBus, obj.numBus);
            for i = 1:obj.numBus
                j = VmOrder(i);
                filter = Topo(:, j);
                filter(j) = false;
                previous = VmOrder(1:i);
                previous = intersect(previous, find(filter));
                
                VmDelta = Vm(filter, :) - repmat(Vm(j, :), sum(filter), 1);
                yG = IP(i, :);
                yB = IQ(i, :);
                try
                    yG = yG - G_ols(previous, j) * VmDelta(filter(previous), :);
                    yB = yB + B_ols(previous, j) * VmDelta(filter(previous), :);
                catch
                    assert (i == 1);
                end
                
                rng(i);
                filter(previous) = false;
                VmDelta = Vm(filter, :) - repmat(Vm(j, :), sum(filter), 1);
%                 G_ols(j, filter) = obj.tls(VmDelta', yG');
                G_ols(j, filter) = yG * VmDelta' / (VmDelta * VmDelta');
                outlier = G_ols(j,:) > -obj.prior.Gmin;
                G_ols(j, filter & outlier') = - obj.prior.Gmin * (1+0.1*rand());
                G_ols(filter, j) = G_ols(j, filter);
                G_ols(j, j) = -sum(G_ols(j, :));
                
                B_ols(j, filter) = - yB * VmDelta' / (VmDelta * VmDelta');
                outlier = B_ols(j,:) < obj.prior.Bmin;
                B_ols(j, filter & outlier') = obj.prior.Bmin * (1+0.1*rand());
                B_ols(filter, j) = B_ols(j, filter);
                B_ols(j, j) = -sum(B_ols(j, :));
            end

            obj.dataE.G = G_ols;
            obj.dataE.B = B_ols;
            
%             obj.dataE.G = (G+G')/2;
%             obj.dataE.B = (B+B')/2;
            
%             obj.dataE.G = obj.data.G;
%             obj.dataE.B = obj.data.B;
        end
        
        function obj = iterateY(obj)
            % This method iterate Y matrix considering the measurement
            % error from both inputs and outputs.
            
            % We first assume a flat diagonal element setting
            W = ones(obj.numBus*2, 1);
            obj = optimizeY(obj, W);
        end
        
        function [obj, Gopt, Bopt] = optimizeY(obj, W)
            % This method use some convex optimization method and provide
            % the G and B matrix
            
            % control variables
            G = sdpvar(obj.numBus, obj.numBus);
            B = sdpvar(obj.numBus, obj.numBus);
            % anxillary variables
            Pres = sdpvar(obj.numBus, obj.numSnap);
            Qres = sdpvar(obj.numBus, obj.numSnap);
            
            % constraints
            constP = Pres == G * obj.data.Vm_noised - obj.data.IP_noised;
            constQ = Qres == - B * obj.data.Vm_noised - obj.data.IQ_noised;
            constG = sum(G) == zeros(1, obj.numBus);
            constB = sum(B) == zeros(1, obj.numBus);
            constraints = [constP; constQ; constG; constB];
            for i = 1:obj.numBus
                for j = i+1:obj.numBus
                    constraints = [constraints; G(i,j)<=0];
                    constraints = [constraints; B(i,j)>=0];
                end
            end
            
            % objective function
            objective = sum(W(1:obj.numBus)' * (Pres .* Pres)...
                + W(1+obj.numBus:end)' * (Qres .* Qres));
            options = sdpsettings('solver','gurobi');
            sol = optimize(constraints,objective,options);
            
            Gopt = value(G);
            Bopt = value(B);
        end
        
        function obj = initValue(obj)
            % This method provides the initial value (voltage angles?)
            
        end
        
        function obj = identifyOptNLP(obj)
            % This method simply use the nonlinar programming techique to
            % solve the maximum identification problem
            
            % This version we simply assume we have all the measurements
            % We should bound all the control variables and all the
            % anxillary variables
            
            % control variables
            G = sdpvar(obj.numBus, obj.numBus);
            B = sdpvar(obj.numBus, obj.numBus);
            Pest = sdpvar(obj.numBus, obj.numSnap);
            Qest = sdpvar(obj.numBus, obj.numSnap);
            Vm = sdpvar(obj.numBus, obj.numSnap);
            Va = sdpvar(obj.numBus, obj.numSnap);
            % anxillary variables
            e_P = sdpvar(obj.numBus, obj.numSnap);
            e_Q = sdpvar(obj.numBus, obj.numSnap);
            e_Vm = sdpvar(obj.numBus, obj.numSnap);
            e_Va = sdpvar(obj.numBus, obj.numSnap);
            Theta_ij = sdpvar(obj.numBus, obj.numBus, obj.numSnap);
            GBThetaP = sdpvar(obj.numBus, obj.numBus, obj.numSnap);
            GBThetaQ = sdpvar(obj.numBus, obj.numBus, obj.numSnap);
            % some constaints
            maxGB = 1000;
            maxNoise = 10;
            
            % constraints
            Constraints = [];
            % the power flow equation, P and Q injections
            for snap = 1:obj.numSnap
                Theta_ij(:,:,snap) = repmat(Va(:, snap), 1, obj.numBus) - repmat(Va(:, snap)', obj.numBus, 1);
                % G_ij\cos(\Theta_ij)+B_ij\sin(\Theta_ij)
                GBThetaP(:,:,snap) = G .* cos(Theta_ij(:,:,snap)) + B .* sin(Theta_ij(:,:,snap));
                % G_ij\sin(\Theta_ij)-B_ij\cos(\Theta_ij)
                GBThetaQ(:,:,snap) = G .* sin(Theta_ij(:,:,snap)) - B .* cos(Theta_ij(:,:,snap));
                Constraints = [Constraints; Pest(:, snap) == (GBThetaP(:,:,snap) * Vm(:, snap)) .* Vm(:, snap)];
                Constraints = [Constraints; Qest(:, snap) == (GBThetaQ(:,:,snap) * Vm(:, snap)) .* Vm(:, snap)];
            end
            % the anxillary variable constraints
            Constraints = [Constraints; Pest + e_P == obj.data.P_noised];
            Constraints = [Constraints; Qest + e_Q == obj.data.Q_noised];
            Constraints = [Constraints; Vm + e_Vm == obj.data.Vm_noised];
            Constraints = [Constraints; Va + e_Va == obj.data.Va_noised];
            % zero noise for reference bus
            Constraints = [Constraints; e_Va(1,:) == zeros(1, obj.numSnap)];
            Constraints = [Constraints; e_Vm(1,:) == zeros(1, obj.numSnap)];
            % the sum of G and B
            Constraints = [Constraints; sum(G) == zeros(1, obj.numBus)];
            Constraints = [Constraints; sum(B) == zeros(1, obj.numBus)];
            % bound all the variables
%             for i = 1:obj.numBus
%                 for j = i+1:obj.numBus
%                     Constraints = [Constraints; -maxGB <= G(i,j) <= 0];
%                     Constraints = [Constraints; 0 <= B(i,j) <= maxGB];
%                 end
%             end
            Constraints = [Constraints; -obj.sigma.P*ones(1, obj.numSnap)*maxNoise <= e_P <= obj.sigma.P*ones(1, obj.numSnap)*maxNoise];
            Constraints = [Constraints; -obj.sigma.Q*ones(1, obj.numSnap)*maxNoise <= e_Q <= obj.sigma.Q*ones(1, obj.numSnap)*maxNoise];
            Constraints = [Constraints; -obj.sigma.Vm*ones(1, obj.numSnap)*maxNoise <= e_Vm <= obj.sigma.Vm*ones(1, obj.numSnap)*maxNoise];
            Constraints = [Constraints; -obj.sigma.Va*ones(1, obj.numSnap)*maxNoise <= e_Va <= obj.sigma.Va*ones(1, obj.numSnap)*maxNoise];
            
            % assign the initial value
            assign(G, obj.dataE.G);
            assign(B, obj.dataE.B);
            assign(Vm, obj.data.Vm_noised);
            assign(Va, obj.data.Va_noised);
            
            % objective function
            objective = sum((obj.sigma.P.^-2)' * (e_P.*e_P) ...
                + (obj.sigma.Q.^-2)' * (e_Q.*e_Q)...
                + (obj.sigma.Vm(2:end).^-2)' * (e_Vm(2:end,:).*e_Vm(2:end,:))...
                + (obj.sigma.Va(2:end).^-2)' * (e_Va(2:end,:).*e_Va(2:end,:)));
            options = sdpsettings('solver','ipopt','ipopt.max_iter',3000);
            sol = optimize(Constraints,objective,options);
            
            Gopt = value(G);
            Bopt = value(B);
            Pestopt = value(Pest);
            Qestopt = value(Qest);
            Vmopt = value(Vm);
            Vaopt = value(Va);
            e_Popt = value(e_P);
            e_Qopt = value(e_Q);
            e_Vmopt = value(e_Vm);
            e_Vaopt = value(e_Va);
        end
        
        function obj = identifyOptGradient(obj)
            % This method uses gradient-based method to solve the nonconvex
            % optimization problem.
            % Hopefully we could implement some power system domain
            % knowledge into the process because we know the ground truth
            % value.
            
            % we first initialize data
            obj.dataO.G = obj.dataE.G;
            obj.dataO.B = obj.dataE.B;
            % note that we should replace the Vm ro Va data to some
            % initialized data if we do not have the measurement devices
            obj.dataO.Vm = obj.data.Vm_noised;
            obj.dataO.Va = obj.data.Va_noised;
            
            % obtain the weight for updating the parameters
            
            % build the gradient
            obj = buildGradient(obj);
            % tune the gradient vector
            s = sqrt(obj.gradP .^ 2 + 1e-4);
            
            temp = obj.gradP ./ s;
        end
        
        function obj = buildGradient(obj)
            % This method build the gradient of the squared loss function
            
            % Initialize the gradient matrix
            obj.numGrad.G = (obj.numBus - 1) * obj.numBus / 2; % exclude the diagonal elements
            obj.numGrad.B = (obj.numBus - 1) * obj.numBus / 2;
            obj.numGrad.Vm = obj.numSnap * (obj.numBus - 1); % exclude the source bus
            obj.numGrad.Va = obj.numSnap * (obj.numBus - 1);
            obj.numGrad.Sum = obj.numGrad.G + obj.numGrad.B + obj.numGrad.Vm + obj.numGrad.Va;
            
            obj.grad = zeros(obj.numGrad.Sum, 1);
            obj.gradP = zeros(obj.numGrad.Sum, 1);
            obj.gradQ = zeros(obj.numGrad.Sum, 1);
            obj.gradVm = zeros(obj.numGrad.Sum, 1);
            obj.gradVa = zeros(obj.numGrad.Sum, 1);
            
            for i = 1:obj.numSnap
                % calculate some basic parameters at present state
                Theta_ij = repmat(obj.dataO.Va(:, i), 1, obj.numBus) - repmat(obj.dataO.Va(:, i)', obj.numBus, 1);
                % G_ij\cos(\Theta_ij)+B_ij\sin(\Theta_ij)
                GBThetaP = obj.dataO.G .* cos(Theta_ij) + obj.dataO.B .* sin(Theta_ij);
                % G_ij\sin(\Theta_ij)-B_ij\cos(\Theta_ij)
                GBThetaQ = obj.dataO.G .* sin(Theta_ij) - obj.dataO.B .* cos(Theta_ij);
                % P estimate
                Pest = (GBThetaP * obj.data.Vm(:, i)) .* obj.data.Vm(:, i);
                % Q estimate
                Qest = (GBThetaQ * obj.data.Vm(:, i)) .* obj.data.Vm(:, i);
                
                % calculate the sub-vector of P of all buses
                for j = 1:obj.numBus
                    if obj.isMeasure.P(j)
                        obj = buildGradientP(obj, i, j, GBThetaP, GBThetaQ, Pest);
                    end
                end
                
                % calculate the sub-vector of Q of all buses
                for j = 1:obj.numBus
                    if obj.isMeasure.Q(j)
                        obj = buildGradientQ(obj, i, j, GBThetaP, GBThetaQ, Qest);
                    end
                end
                
                % calculate the sub-vector of Vm of all buses
                for j = 1:obj.numBus
                    if obj.isMeasure.Vm(j)
                        obj = buildGradientVm(obj, i, j);
                    end
                end
                
                % calculate the sub-vector of Va of all buses
                for j = 1:obj.numBus
                    if obj.isMeasure.Va(j)
                        obj = buildGradientVa(obj, i, j);
                    end
                end
            end
            
            % collect the gradients
            obj.grad = obj.gradP + obj.gradQ + obj.gradVm + obj.gradVa;
        end
        
        function obj = buildGradientP(obj , snap, bus, GBThetaP, GBThetaQ, Pest)
            % This method builds the gradient from the measurement of P
            
            theta_ij = obj.dataO.Va(bus, snap) - obj.dataO.Va(:, snap);
            g = zeros(obj.numGrad.Sum, 1);
            
            % G matrix
            H_G = zeros(obj.numBus, obj.numBus);
            H_G(bus, :) = obj.dataO.Vm(bus, snap) * obj.dataO.Vm(:, snap)' .* cos(theta_ij');
            H_G(bus, :) = H_G(bus, :) - obj.dataO.Vm(bus, snap)^2; % the equivilance of diagonal elements
            h_G = obj.matToColDE(H_G);
            g(1:obj.numGrad.G) = h_G;
            
            % B matrix
            H_B = zeros(obj.numBus, obj.numBus);
            H_B(bus, :) = obj.dataO.Vm(bus, snap) * obj.dataO.Vm(:, snap)' .* sin(theta_ij');
            h_B = obj.matToColDE(H_B);
            g(obj.numGrad.G+1:obj.numGrad.G+obj.numGrad.B) = h_B;
            
            % Vm
            % the first order term of other Vm
            H_Vm = zeros(obj.numBus, obj.numSnap);
            h_Vm = obj.dataO.Vm(bus, snap) * GBThetaP(:, bus);
            % the second order term of Vm(bus)
            h_Vm(bus) = 2*obj.dataO.Vm(bus, snap) * GBThetaP(bus, bus);
            % the first order term of Vm(bus)
            fOrderVm = obj.dataO.Vm(:, snap) .* GBThetaP(:, bus);
            fOrderVm(bus) = 0;
            h_Vm(bus) = h_Vm(bus) + sum(fOrderVm);
            H_Vm(:, snap) = h_Vm;
            % remove the source bus whose magnitude is not the state variable
            H_Vm(1, :) = []; 
            h_VmLarge = reshape(H_Vm', [], 1);
            g(obj.numGrad.G+obj.numGrad.B+1:obj.numGrad.G+obj.numGrad.B+obj.numGrad.Vm) = h_VmLarge;
            
            % Va
            H_Va = zeros(obj.numBus, obj.numSnap);
            h_Va = obj.dataO.Vm(bus, snap) * obj.dataO.Vm(:, snap) .* GBThetaQ(:, bus);
            h_Va(bus) = h_Va(bus)-sum(obj.dataO.Vm(bus, snap) * obj.dataO.Vm(:, snap) .* GBThetaQ(:, bus));
            H_Va(:, snap) = h_Va;
            % remove the source bus whose magnitude is not the state variable
            H_Va(1, :) = []; 
            h_VaLarge = reshape(H_Va', [], 1);
            g(obj.numGrad.G+obj.numGrad.B+obj.numGrad.Vm+1:end) = h_VaLarge;
            
            % build GradientP
            gradPThis = obj.sigma.P(bus).^(-2) * (Pest(bus) - obj.data.P_noised(bus, snap)) * g;
            obj.gradP = obj.gradP + gradPThis;
        end
        
        function obj = buildGradientQ(obj , snap, bus, GBThetaP, GBThetaQ, Qest)
            % This method builds the gradient from the measurement of Q
            
            theta_ij = obj.dataO.Va(bus, snap) - obj.dataO.Va(:, snap);
            g = zeros(obj.numGrad.Sum, 1);
            
            % G matrix
            H_G = zeros(obj.numBus, obj.numBus);
            H_G(bus, :) = obj.dataO.Vm(bus, snap) * obj.dataO.Vm(:, snap)' .* sin(theta_ij');
            h_G = obj.matToColDE(H_G);
            g(1:obj.numGrad.G) = h_G;
            
            % B matrix
            H_B = zeros(obj.numBus, obj.numBus);
            H_B(bus, :) = - obj.dataO.Vm(bus, snap) * obj.dataO.Vm(:, snap)' .* cos(theta_ij');
            H_B(bus, :) = H_B(bus, :) + obj.dataO.Vm(bus, snap)^2; % the equivilance of diagonal elements
            h_B = obj.matToColDE(H_B);
            g(obj.numGrad.G+1:obj.numGrad.G+obj.numGrad.B) = h_B;
            
            % Vm
            % the first order term of other Vm
            H_Vm = zeros(obj.numBus, obj.numSnap);
            h_Vm = obj.dataO.Vm(bus, snap) * GBThetaQ(:, bus);
            % the second order term of Vm(bus)
            h_Vm(bus) = 2*obj.dataO.Vm(bus, snap) * GBThetaQ(bus, bus);
            % the first order term of Vm(bus)
            fOrderVm = obj.dataO.Vm(:, snap) .* GBThetaQ(:, bus);
            fOrderVm(bus) = 0;
            h_Vm(bus) = h_Vm(bus) + sum(fOrderVm);
            H_Vm(:, snap) = h_Vm;
            % remove the source bus whose magnitude is not the state variable
            H_Vm(1, :) = []; 
            h_VmLarge = reshape(H_Vm', [], 1);
            g(obj.numGrad.G+obj.numGrad.B+1:obj.numGrad.G+obj.numGrad.B+obj.numGrad.Vm) = h_VmLarge;
            
            % Va
            H_Va = zeros(obj.numBus, obj.numSnap);
            h_Va = - obj.dataO.Vm(bus, snap) * obj.dataO.Vm(:, snap) .* GBThetaP(:, bus);
            h_Va(bus) = h_Va(bus)+sum(obj.dataO.Vm(bus, snap) * obj.dataO.Vm(:, snap) .* GBThetaP(:, bus));
            H_Va(:, snap) = h_Va;
            % remove the source bus whose magnitude is not the state variable
            H_Va(1, :) = []; 
            h_VaLarge = reshape(H_Va', [], 1);
            g(obj.numGrad.G+obj.numGrad.B+obj.numGrad.Vm+1:end) = h_VaLarge;
            
            % build GradientQ
            gradQThis = obj.sigma.Q(bus).^(-2) * (Qest(bus) - obj.data.Q_noised(bus, snap)) * g;
            obj.gradQ = obj.gradQ + gradQThis;
        end
        
        function obj = buildGradientVm(obj, snap, bus)
            % This method builds the gradient from the measurement of Vm
            g = zeros(obj.numGrad.Sum, 1);
            H_Vm = zeros(obj.numBus, obj.numSnap);
            H_Vm(bus, snap) = 1 / (obj.sigma.Vm(bus)^2);
            % remove the source bus whose magnitude is not the state variable
            H_Vm(1, :) = []; 
            h_VmLarge = reshape(H_Vm', [], 1);
            g(obj.numGrad.G+obj.numGrad.B+1:obj.numGrad.G+obj.numGrad.B+obj.numGrad.Vm) = h_VmLarge;
            
            % build GradientVm
            gradVmThis = (obj.dataO.Vm(bus, snap) - obj.data.Vm_noised(bus, snap)) * g;
            obj.gradVm = obj.gradVm + gradVmThis;
        end
        
        function obj = buildGradientVa(obj, snap, bus)
            % This method builds the gradient from the measurement of Va
            g = zeros(obj.numGrad.Sum, 1);
            H_Va = zeros(obj.numBus, obj.numSnap);
            H_Va(bus, snap) = 1 / (obj.sigma.Va(bus)^2);
            % remove the source bus whose angle is not the state variable
            H_Va(1, :) = []; 
            h_VaLarge = reshape(H_Va', [], 1);
            g(obj.numGrad.G+obj.numGrad.B+obj.numGrad.Vm+1:end) = h_VaLarge;
            
            % build GradientVa
            gradVaThis = (obj.dataO.Va(bus, snap) - obj.data.Va_noised(bus, snap)) * g;
            obj.gradVa = obj.gradVa + gradVaThis;
        end
        
        function obj = identifyMCMCEIV(obj)
            % This method uses the Markov Chain Monte Carlo to sample the
            % distribution of the parameters and the topologies. We use the
            % error-in-variables(EIV) assumption.
            
            % Build the measurement function.
            % Currently, we assume we know all the P, Q, Vm, Va
            % measurements. We have to modify it later.
            data.Pn = obj.data.P_noised;
            data.Qn = obj.data.Q_noised;
            data.Vmn = obj.data.Vm_noised;
            data.Van = obj.data.Va_noised;
            data.num = obj.numFIM;
            data.isMeasure = obj.isMeasure;
            data.sigma = obj.sigma;
            
            % build the parameters
            G = obj.matOfCol(obj.dataE.G);
            B = obj.matOfCol(obj.dataE.B);
            Vm = reshape(obj.data.Vm_noised(2:end,:), [], 1); % we assume the value of the source bus is already known
            Va = reshape(obj.data.Va_noised(2:end,:), [], 1);
            par = [G' B' Vm' Va'];
            assert (length(par) == obj.numFIM.Sum) % the number of total parameters
            
            % we also build the ground truth value of the parameters
            Gtr = obj.matOfCol(obj.data.G);
            Btr = obj.matOfCol(obj.data.B);
            Vmtr = reshape(obj.data.Vm(2:end,:), [], 1);
            Vatr = reshape(obj.data.Va(2:end,:), [], 1);
            obj.truePar = [Gtr' Btr' Vmtr' Vatr'];
            
            % build the params in the format of mcmc
            params = cell(1, data.num.Sum);
            for i = 1:data.num.G
                params{i} = ...
                    {sprintf('G_{%d}',i), G(i), -Inf, Inf, obj.boundA.total(i)};
            end
            for i = 1:data.num.B
                params{i+data.num.G} = ...
                    {sprintf('B_{%d}',i), B(i), -Inf, Inf, obj.boundA.total(i+data.num.G)};
            end
            for i = 1:data.num.Vm
                params{i+data.num.G+data.num.B} =...
                    {sprintf('Vm_{%d}',i), Vm(i), Vm(i)*0.99, Vm(i)*1.01, obj.boundA.total(i+data.num.G+data.num.B)};
            end
            for i = 1:data.num.Va
                params{i+data.num.G+data.num.B+data.num.Vm} =...
                    {sprintf('Vm_{%d}',i), Va(i), Va(i)-abs(Va(i))*0.01, Va(i)+abs(Va(i))*0.01, obj.boundA.total(i+data.num.G+data.num.B+data.num.Vm)};
            end
            
            % build the model
            model.ssfun = @sumOfSquaresEIV;
            % build the sigma2 (the sum of squares error of the measurements)
            sigma2P = obj.sigma.P(obj.isMeasure.P).^2';
            sigma2Q = obj.sigma.Q(obj.isMeasure.Q).^2';
            sigma2Vm = obj.sigma.Vm(obj.isMeasure.Vm).^2';
            sigma2Va = obj.sigma.Va(obj.isMeasure.Va).^2';
            model.sigma2 = [sigma2P sigma2Q sigma2Vm sigma2Va] * obj.numSnap.^2 *1000;
            model.S20 = model.sigma2;
            model.N = obj.numSnap;
            
            % build the options
            options.nsimu = 500000;
            options.qcov = obj.boundA.cov;
            numGB = obj.numFIM.G+obj.numFIM.B;
            options.qcov(1:numGB,1:numGB) = options.qcov(1:numGB,1:numGB) * 1;
%             options.updatesigma = 1;

            % run the mcmc simulation
            [res,chain,s2chain] = mcmcrun(model,data,params,options);
            
            % run the mcmc simulation and update the cov matrix iteratively
            options.nsimu = 2000;
            numIter = 10;
            Gs = cell(1, numIter);
            Bs = cell(1, numIter);
            chains = [];
            errorInit = sum(sumOfSquaresEIV(par, data) ./ model.sigma2);
            errorTrue = sum(sumOfSquaresEIV(obj.truePar, data) ./ model.sigma2);
            errorEval = sum(sumOfSquaresEIV(res.theta', data) ./ model.sigma2);
            for i = 1:10
                [res,chain,~] = mcmcrun(model,data,params,options);
                errorEval = sum(sumOfSquaresEIV(res.theta', data) ./ model.sigma2)
                Gs{i} = res.theta(1:data.num.G);
                Bs{i} = res.theta(1+data.num.G:data.num.G+data.num.B);
                chains = [chains;chain];
                % rebuild the FIM matrix and the cov matrix
                obj.dataE.G = obj.colToMat(Gs{i}, obj.numBus);
                obj.dataE.B = obj.colToMat(Bs{i}, obj.numBus);
                obj = approximateFIM(obj);
                obj = calABound(obj);
                options.qcov = obj.boundA.cov;
                numGB = obj.numFIM.G+obj.numFIM.B;
                options.qcov(1:numGB,1:numGB) = options.qcov(1:numGB,1:numGB)*100;
            end
            errorInit = sum(sumOfSquaresEIV(par, data) ./ model.sigma2);
            errorTrue = sum(sumOfSquaresEIV(obj.truePar, data) ./ model.sigma2);
            errorEval = sum(sumOfSquaresEIV(res.theta', data) ./ model.sigma2);
        end
        
        function obj = identifyMCMCEIO(obj)
            % This method uses the Markov Chain Monte Carlo to sample the
            % distribution of the parameters and the topologies. We use the
            % error-in-outputs(EIV) assumption.
            % Build the measurement function.
            
            % Currently, we assume we know all the P, Q, Vm, Va
            % measurements. We have to modify it later.
            data.Pn = obj.data.P_noised;
            data.Qn = obj.data.Q_noised;
            data.Vmn = obj.data.Vm_noised;
            data.Van = obj.data.Va_noised;
            data.num = obj.numFIM;
            data.isMeasure = obj.isMeasure;
            data.sigma = obj.sigma;
            
            % build the parameters
%             G = obj.matOfCol(obj.dataE.G);
%             B = obj.matOfCol(obj.dataE.B);
            G = obj.matOfCol(obj.data.G);
            B = obj.matOfCol(obj.data.B);
            par = [G' B'];
            
            % we also build the ground truth value of the parameters
            Gtr = obj.matOfCol(obj.data.G);
            Btr = obj.matOfCol(obj.data.B);
            obj.truePar = [Gtr' Btr'];
            
            % build the params in the format of mcmc
            params = cell(1, data.num.G+data.num.B);
            for i = 1:data.num.G
                params{i} = ...
                    {sprintf('G_{%d}',i), G(i), -Inf, Inf, obj.boundA.total(i)};
            end
            for i = 1:data.num.B
                params{i+data.num.G} = ...
                    {sprintf('B_{%d}',i), B(i), -Inf, Inf, obj.boundA.total(i+data.num.G)};
            end
            
            % build the model
            model.ssfun = @sumOfSquaresEIO;
            % build the sigma2 (the sum of squares error of the measurements)
            % we use the summation of G and B matrices to approximate the
            % first order of measurement noises
%             sumG = diag(obj.dataE.G);
%             sumB = diag(obj.dataE.B);
            sumG = diag(obj.data.G);
            sumB = diag(obj.data.B);
            sigma2P = sumG(obj.isMeasure.P).^2';
            sigma2Q = sumB(obj.isMeasure.Q).^2';
            model.sigma2 = [sigma2P sigma2Q] / 10000000;
            model.S20 = model.sigma2;
            model.N = obj.numSnap;
            
            % build the options
            options.nsimu = 50000;
            numGB = obj.numFIM.G+obj.numFIM.B;
            options.qcov = obj.boundA.cov(1:numGB, 1:numGB);
            
            % run the mcmc
            [res,chain,s2chain] = mcmcrun(model,data,params,options);
            errorInit = sum(sumOfSquaresEIO(par, data) ./ model.sigma2);
            errorTrue = sum(sumOfSquaresEIO(obj.truePar, data) ./ model.sigma2);
            errorEval = sum(sumOfSquaresEIO(res.theta', data) ./ model.sigma2);
        end
    end
    
    methods (Static)
        function B = tls(xdata,ydata)
            % This method con
            SUM = sum(xdata,1);
            zero = find(SUM==0);
            xdata(:,zero)=[];

%             m       = length(ydata);       %number of x,y data pairs
            X       = xdata;
            Y       = ydata;
            n       = size(X,2);          % n is the width of X (X is m by n)
            Z       = [X Y];              % Z is X augmented with Y.
            [~, ~, V] = svd(Z,0);         % find the SVD of Z.
            VXY     = V(1:n,1+n:end);     % Take the block of V consisting of the first n rows and the n+1 to last column
            VYY     = V(1+n:end,1+n:end); % Take the bottom-right block of V.
            B       = -VXY/VYY;

            for i = zero
                B = [B(1:i-1); 0; B(i:end)];
            end
        end
        
        function h = matOfCol(H)
            % This method get the half triangle of a matrix
            H_up = tril(H, 1)';
            n = size(H, 1);
            N = (n + 1) * n / 2;
            h = zeros(N, 1);
            pt = 1;
            for i = 1:n
                h(pt:pt+n-i) = H_up(i, i:end);
                pt = pt+n-i+1;
            end
        end
        
    end
end

