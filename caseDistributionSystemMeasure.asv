classdef caseDistributionSystemMeasure < caseDistributionSystem
    % This is the class of distribution system. We assume all the
    % evaluations are conducted under practical measurements
    
    properties
        dataE               % the estimated data
        boundA              % the approximated bound
        
        A_FIM               % the approximated fisher information matrix
        A_FIMP              % the (sparse) FIM of active power injection
        A_FIMQ              % the (sparse) FIM of reactive power injection
    end
    
    methods
        function obj = caseDistributionSystemMeasure(caseName, numSnap, range)
            % the construction function
            obj = obj@caseDistributionSystem(caseName, numSnap, range);
        end
        
        function obj = preEvaluation(obj)
            % This method evaluate the parameters before approximating the
            % FIM. The evaluated value has low accuracy. We only use one
            % snapshot for the Vm and Va.
            
            % The first version is extremely simple
            
            % we first evaluate the vm
            obj.dataE.Vm = obj.data.Vm_noised;
            
            % We then evaluate the G and B. 
            obj.dataE.G = obj.data.G;
            obj.dataE.B = obj.data.B;
        end
        
        function obj = approximateFIM(obj, varargin)
            % This method approximate the fisher information matrix based
            % on the pre-evaluation results of the parameters.
            if nargin == 2
                obj.k = varargin{1};
            elseif nargin == 1
                obj.k.G = 5;
                obj.k.B = 10;
                obj.k.vm = 10;
                obj.k.va = 1000;
            end
            % initialize the A_FIM matrix
            obj.numFIM.G = (1 + obj.numBus) * obj.numBus / 2;
            obj.numFIM.B = (1 + obj.numBus) * obj.numBus / 2;
            obj.numFIM.Vm = obj.numSnap * (obj.numBus - 1); % exclude the source bus
            obj.numFIM.Va = obj.numSnap * (obj.numBus - 1);
            obj.numFIM.Sum = obj.numFIM.G + obj.numFIM.B + obj.numFIM.Vm + obj.numFIM.Va;
            
            obj.A_FIM = zeros(obj.numFIM.Sum, obj.numFIM.Sum);
            obj.A_FIMP = sparse(obj.numFIM.Sum, obj.numFIM.Sum);
            obj.A_FIMQ = sparse(obj.numFIM.Sum, obj.numFIM.Sum);
            obj.FIMVm = sparse(obj.numFIM.Sum, obj.numFIM.Sum);
            obj.FIMVa = sparse(obj.numFIM.Sum, obj.numFIM.Sum);
            
            % calculate the sub-matrix of P of all snapshots and all buses
            for i = 1:obj.numBus
                if obj.isMeasure.P(i)
                    for j = 1:obj.numSnap
                        obj = approximateFIMP(obj, i, j);
                    end
                end
            end
            obj.A_FIM = obj.A_FIM + full(obj.A_FIMP);
            % calculate the sub-matrix of Q of all snapshots and all buses
            for i = 1:obj.numBus
                if obj.isMeasure.Q(i)
                    for j = 1:obj.numSnap
                        obj = approximateFIMQ(obj, i, j);
                    end
                end
            end
            obj.A_FIM = obj.A_FIM + full(obj.A_FIMQ);
            % calculate the sub-matrix of Vm of all snapshots and all buses
            for i = 1:obj.numBus
                if obj.isMeasure.Vm(i)
                    for j = 1:obj.numSnap
                        obj = buildFIMVm(obj, i, j);
                    end
                end
            end
            obj.A_FIM = obj.A_FIM + full(obj.FIMVm);
            % calculate the sub-matrix of Va of all snapshots and all buses
            for i = 1:obj.numBus
                if obj.isMeasure.Va(i)
                    for j = 1:obj.numSnap
                        obj = buildFIMVa(obj, i, j);
                    end
                end
            end
            obj.A_FIM = obj.A_FIM + full(obj.FIMVa);
        end
        
        function obj = approximateFIMP(obj, bus, snap)
            % This method approximate the P part of FIM. We ignore the sin
            % part of the power flow equations.
            h = sparse(obj.numFIM.Sum, 1);
            
            % G matrix
            H_G = zeros(obj.numBus, obj.numBus);
            H_G(bus, :) = obj.dataE.Vm(bus, snap) * obj.dataE.Vm(:, snap)' / obj.k.G;
            h_G = obj.matToCol(H_G);
            h(1:obj.numFIM.G) = h_G;
            
            % Vm
            % the first order term of other Vm
            H_Vm = zeros(obj.numBus, obj.numSnap);
            h_Vm = obj.dataE.Vm(bus, snap) * obj.dataE.G(:, bus) / obj.k.vm;
            % the second order term of Vm(bus)
            h_Vm(bus) = 2*obj.dataE.Vm(bus, snap) * obj.dataE.G(bus, bus) / obj.k.vm;
            % the first order term of Vm(bus)
            fOrderVm = obj.dataE.Vm(:, snap) .* obj.dataE.G(:, bus) / obj.k.vm;
            fOrderVm(bus) = 0;
            h_Vm(bus) = h_Vm(bus) + sum(fOrderVm);
            H_Vm(:, snap) = h_Vm;
            % remove the source bus whose magnitude is not the state variable
            H_Vm(1, :) = []; 
            h_VmLarge = reshape(H_Vm', [], 1);
            h(obj.numFIM.G+obj.numFIM.B+1:obj.numFIM.G+obj.numFIM.B+obj.numFIM.Vm) = h_VmLarge;
            
            % Va
            H_Va = zeros(obj.numBus, obj.numSnap);
            h_Va = obj.dataE.Vm(bus, snap) * obj.dataE.Vm(:, snap) .* (- obj.dataE.B(:, bus)) / obj.k.va;
            h_Va(bus) = h_Va(bus)-sum(obj.dataE.Vm(bus) * obj.dataE.Vm .* (- obj.dataE.B(:, bus))) / obj.k.va;
            H_Va(:, snap) = h_Va;
            % remove the source bus whose magnitude is not the state variable
            H_Va(1, :) = []; 
            h_VaLarge = reshape(H_Va', [], 1);
            h(obj.numFIM.G+obj.numFIM.B+obj.numFIM.Vm+1:end) = h_VaLarge;
            
            % build FIMP
            h = h / obj.sigma.P(bus);
            FIMPThis = h * h';
            obj.A_FIMP = obj.A_FIMP + FIMPThis;
        end
        
        function obj = approximateFIMQ(obj, bus, snap)
            % This method approximate the Q part of FIM. We ignore the sin
            % part of the power flow equations.
            h = sparse(obj.numFIM.Sum, 1);
            
            % B matrix
            H_B = zeros(obj.numBus, obj.numBus);
            H_B(bus, :) = - obj.dataE.Vm(bus, snap) * obj.dataE.Vm(:, snap)' / obj.k.B;
            h_B = obj.matToCol(H_B);
            h(obj.numFIM.G+1:obj.numFIM.G+obj.numFIM.B) = h_B;
            
            % Vm
            % the first order term of other Vm
            H_Vm = zeros(obj.numBus, obj.numSnap);
            h_Vm = obj.dataE.Vm(bus, snap) * (-obj.dataE.B(:, bus)) / obj.k.vm;
            % the second order term of Vm(bus)
            h_Vm(bus) = 2*obj.dataE.Vm(bus, snap) * (-obj.dataE.B(bus, bus)) / obj.k.vm;
            % the first order term of Vm(bus)
            fOrderVm = obj.dataE.Vm(:, snap) .* (-obj.dataE.B(:, bus)) / obj.k.vm;
            fOrderVm(bus) = 0;
            h_Vm(bus) = h_Vm(bus) + sum(fOrderVm);
            H_Vm(:, snap) = h_Vm;
            % remove the source bus whose magnitude is not the state variable
            H_Vm(1, :) = []; 
            h_VmLarge = reshape(H_Vm', [], 1);
            h(obj.numFIM.G+obj.numFIM.B+1:obj.numFIM.G+obj.numFIM.B+obj.numFIM.Vm) = h_VmLarge;
            
            % Va
            H_Va = zeros(obj.numBus, obj.numSnap);
            h_Va = - obj.dataE.Vm(bus) * obj.dataE.Vm .* obj.dataE.G(:, bus) / obj.k.va;
            h_Va(bus) = h_Va(bus)+sum(obj.dataE.Vm(bus) * obj.dataE.Vm .* obj.dataE.G(:, bus)) / obj.k.va;
            H_Va(:, snap) = h_Va;
            % remove the source bus whose magnitude is not the state variable
            H_Va(1, :) = []; 
            h_VaLarge = reshape(H_Va', [], 1);
            h(obj.numFIM.G+obj.numFIM.B+obj.numFIM.Vm+1:end) = h_VaLarge;
            
            % build FIMQ
            h = h / obj.sigma.Q(bus);
            FIMQThis = h * h';
            obj.A_FIMQ = obj.A_FIMQ + FIMQThis;
        end
        
        function obj = calABound(obj, varargin)
            % this method calculate the bound from the A_FIM matrix;
            
            if nargin == 3
                obj.admittanceOnly = varargin{1};
                obj.topoPrior = varargin{2};
            elseif nargin == 2
                obj.admittanceOnly = varargin{1};
                obj.topoPrior = false(obj.numBus, obj.numBus);
            elseif nargin == 1
                obj.admittanceOnly = false;
                obj.topoPrior = false(obj.numBus, obj.numBus);
            end
            
            % build the indexes we really care about
            delCols = [obj.matToCol(obj.topoPrior)>1e-4;obj.matToCol(obj.topoPrior)>1e-4];
            obj.numFIM.index = true(obj.numFIM.Sum, 1);
            obj.numFIM.index(delCols) = false;
            obj.numFIM.del = sum(delCols)/2;
            
            % for [A B; B' C], we calculate A-B/C*B'
            if obj.admittanceOnly
                obj.numFIM.index = obj.numFIM.index(1:obj.numFIM.G+obj.numFIM.B);
                A = obj.A_FIM(1:obj.numFIM.G+obj.numFIM.B, 1:obj.numFIM.G+obj.numFIM.B);
                B = obj.A_FIM(1:obj.numFIM.G+obj.numFIM.B, obj.numFIM.G+obj.numFIM.B+1:end);
                C = obj.A_FIM(obj.numFIM.G+obj.numFIM.B+1:end, obj.numFIM.G+obj.numFIM.B+1:end);
                obj.A_FIM = A - B/C*B';
                var = diag(obj.A_FIM(obj.numFIM.index, obj.numFIM.index)\eye(sum(obj.numFIM.index)));
            else
                var = diag(obj.A_FIM(obj.numFIM.index, obj.numFIM.index)\eye(sum(obj.numFIM.index)));
            end
            if min(var) < 0
                var = abs(var);
                fprintf('We use the absolute value of the variance.\n');
            end
            
            obj.boundA.total = sqrt(var);
            
            boundG = zeros(obj.numFIM.G, 1);
            boundG(obj.numFIM.index(1:obj.numFIM.G)) = obj.boundA.total(1:obj.numFIM.G-obj.numFIM.del) / obj.k.G;
            obj.boundA.total(1:obj.numFIM.G-obj.numFIM.del) = obj.boundA.total(1:obj.numFIM.G-obj.numFIM.del) / obj.k.G;
            obj.boundA.G = obj.colToMat(boundG, obj.numBus);
            
            boundB = zeros(obj.numFIM.B, 1);
            boundB(obj.numFIM.index(1:obj.numFIM.G)) = ...
                obj.boundA.total(obj.numFIM.G+1-obj.numFIM.del:obj.numFIM.G+obj.numFIM.B-2*obj.numFIM.del) / obj.k.B;
            obj.boundA.total(obj.numFIM.G+1-obj.numFIM.del:obj.numFIM.G+obj.numFIM.B-2*obj.numFIM.del) = ...
                obj.boundA.total(obj.numFIM.G+1-obj.numFIM.del:obj.numFIM.G+obj.numFIM.B-2*obj.numFIM.del) / obj.k.B;
            obj.boundA.B = obj.colToMat(boundB, obj.numBus);
            
            obj.boundA.G_relative = abs(obj.boundA.G ./ repmat(diag(obj.data.G), 1, obj.numBus));
            obj.boundA.B_relative = abs(obj.boundA.B ./ repmat(diag(obj.data.B), 1, obj.numBus));
            
            if ~obj.admittanceOnly
                obj.boundA.Vm = ...
                    obj.boundA.total(obj.numFIM.G+obj.numFIM.B+1-2*obj.numFIM.del...
                    :obj.numFIM.G+obj.numFIM.B+obj.numFIM.Vm-2*obj.numFIM.del) / obj.k.vm;
                obj.boundA.total(obj.numFIM.G+obj.numFIM.B+1-2*obj.numFIM.del...
                    :obj.numFIM.G+obj.numFIM.B+obj.numFIM.Vm-2*obj.numFIM.del)...
                    = obj.boundA.Vm;
                obj.boundA.Va = ...
                    obj.boundA.total(obj.numFIM.G+obj.numFIM.B+obj.numFIM.Vm+1-2*obj.numFIM.del...
                    :obj.numFIM.Sum-2*obj.numFIM.del) / obj.k.va;
                obj.boundA.total(obj.numFIM.G+obj.numFIM.B+obj.numFIM.Vm+1-2*obj.numFIM.del...
                    :obj.numFIM.Sum-2*obj.numFIM.del)...
                    = obj.boundA.Va;
            end
        end
    end
end

